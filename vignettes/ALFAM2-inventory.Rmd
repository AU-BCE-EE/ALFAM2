---
title: "Emissions inventory calculations with the ALFAM2 package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Emissions inventory calculations with the ALFAM2 package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE, cache=FALSE}
library(knitr)
knitr::opts_chunk$set(fig.width=12, fig.height=8, out.width='100%', out.height='100%') 
opts_chunk$set(cache = FALSE, tidy = FALSE, fig.align = "center")
library(ALFAM2)
options(width=65)
```

# Introduction
An obvious application of the `alfam2()` function is emissions inventory calculations.
The `alfamei()` function simplifies this type of work by

1. estimating uncertainty from both model input variables and parameter values, 
2. aggregating results, and
3. including default arguments and behavior appropriate for inventory calcuations.

Actual emission calculations are made using `alfam2()`.
This document shows how to use the `alfamei` function through examples.
The name of the function comes from 'ALFAM' and **e**missions **i**nventory.

# A simple example

Let's pretend that we are interested in inventory estimates of ammonia emission from field-applied cattle and pig slurry in some geographic area.
We have input data at a geographic scale we'll call "sector" here.
In our hypothetical input data there are two sectors in one of our "zones", and three other zones with one sector each.
We also have some information on the application method in each sector, along with characteristics of slurry applied, and the weather.
(Without data like these, the benefit from using this function for inventory calculations is not clear.)

```{r}
dat <- data.frame(zone = c('north', 'north', 'south', 'east', 'west'),
		  sector = c(1, 2, 1, 1, 1),
		  man.source = c('cattle', 'pig', 'cattle', 'cattle', 'pig'),
		  man.dm = c(7, 4, 6.5, 6.5, 4),
		  man.ph = c(7.0, 7.2, 6.9, 7.5, 7.4),
		  app.mthd = c(rep('trailing hose', 4), 'broadcast'),
		  wind.sqrt = sqrt(c(2.2, 2.1, 4.0, 3.7, 4.0)),
		  air.temp = c(12, 8, 8, 15, 14),
		  time.h = 168,
		  TAN.app.tot = c(2000, 1500, 80, 4300, 25))
dat
```

We might think about whether these data should be further "disaggregated", and whether we might consider how changing weather over the slurry application period affects total emission.
For now we will set these issues aside.

The `alfamei()` function needs these inputs along with a few settings.

```{r}
devtools::load_all()
```

```{r}
args(alfamei)
```

Here we only really need to specify the name of the columns that have: the time after application at which emission should be integrated and total TAN application (N mass) in a known unit.

```{r}
ei <- alfamei(dat, time.name = 'time.h', app.tan.name = 'TAN.app.tot')
```

The function returns a list of 5 elements.

```{r}
names(eipred)
```

For aggregated TAN application and emission, totals in this case, see the following element.

```{r}
ei$emisagg
```

Disaggregated data are included as well.

```{r}
ei$emisdis
```

And to see more detailed ALFAM2 predictions from the `alfam2()` function,

```{r}
ei$predref
```

## Estimating uncertainty

To estimate uncertainty in predicted emissions based on uncertainty in model parameter values, set `r uncert = 'pars')`.

```{r}
ei <- alfamei(dat, time.name = 'time.h', app.tan.name = 'TAN.app.tot',
              uncert = 'pars')
```

```{r}
ei$emisagg
```

The `alfamei()` function can also incorporate uncertainty from `alfam2()` predictor variables, as well as in TAN application.
This requires setting some inputs 


```{r}
uset <- data.frame(pvar = c('man.dm', 'man.ph', 'wind.sqrt', 'air.temp', 'TAN.app.tot'),
		   rel = 'Relative',
		   dist.type = 'Normal',
		   sd = 0.2,
		   min = NA,
		   max = NA)
uset
```

```{r}
ei <- alfamei(dat, time.name = 'time.h', app.tan.name = 'TAN.app.tot',
              uncert = c('pars', 'input'), uncert.settings = uset)
```

```{r}
ei$emisagg
```

Check the values used

```{r}
aggregate(ei$emisuc[, c('man.dm', 'man.ph', 'air.temp', 'wind.sqrt')], 
          ei$emisuc[, c('zone', 'sector')], FUN = range)
```

```{r}
uset[2, c(2:6)] <- list('Centered', 'Uniform', NA, -1, 1)
uset[4, c(2:4)] <- list('Absolute', 'Normal', 2)
uset
```

```{r}
ei <- alfamei(dat, time.name = 'time.h', app.tan.name = 'TAN.app.tot',
              uncert = c('pars', 'input'), uncert.settings = uset)
```

```{r}
aggregate(ei$emisuc[, c('man.ph', 'air.temp')], 
          ei$emisuc[, c('zone', 'sector')], FUN = range)
aggregate(ei$emisuc[, c('man.ph', 'air.temp')], 
          ei$emisuc[, c('zone', 'sector')], FUN = sd)
```

Better!


```{r}
ei$emisagg
```

We can separately look at the contributions of parameter and input variable uncertainty.

Parameters:

```{r}
alfamei(dat, time.name = 'time.h', app.tan.name = 'TAN.app.tot',
        uncert = c('pars'), uncert.settings = uset)$emisagg[, c(4, 3, 5)]
```

Predictor variables:

```{r}
alfamei(dat, time.name = 'time.h', app.tan.name = 'TAN.app.tot',
        uncert = c('vars'), uncert.settings = uset)$emisagg[, c(4, 3, 5)]
```

Together:

```{r}
alfamei(dat, time.name = 'time.h', app.tan.name = 'TAN.app.tot',
        uncert = c('vars', 'pars'), uncert.settings = uset)$emisagg[, c(4, 3, 5)]
```

For reproducibility in uncertainty estimates, the `seed` argument must be used.
(It calls `set.seed()`.)

```{r}
alfamei(dat, time.name = 'time.h', app.tan.name = 'TAN.app.tot',
        uncert = c('vars', 'pars'), uncert.settings = uset, 
        seed = 1)$emisagg[, c(4, 3, 5)]
```

Repeating the call will give an identical result.

```{r}
alfamei(dat, time.name = 'time.h', app.tan.name = 'TAN.app.tot',
        uncert = c('vars', 'pars'), uncert.settings = uset, 
        seed = 1)$emisagg[, c(4, 3, 5)]
```

Note that estimated confidence limits are independent.
So for example, in the result below, the lower limit for total emission is *not* the product of the emission factor and TAN application lower limits, but is higher (less extreme, closer to the main estimate).

```{r}
ei <- alfamei(dat, time.name = 'time.h', app.tan.name = 'TAN.app.tot',
        uncert = c('vars', 'pars'), uncert.settings = uset, 
        seed = 1)$emisagg
ei
ei$emis.fact.lwr * ei$TAN.app.tot.lwr
ei$emis.fact.upr * ei$TAN.app.tot.upr
```

All variables are calculated for each uncertainty iteration, and then quantiles are used to estimate limits, separately for all variables.

# Higher resolution weather

```{r}
wthr <- data.frame(time.h = 0:84*2, 
                   air.temp = 7 + 7*sin(0:84*2 * 2*pi/24) + 
                     rnorm(85, 0, 2), 
                   wind.sqrt = sqrt(1.5 + 0.4*sin(0:84*2 * 2*pi/24)) + 
                      rnorm(85, 0, 0.12)) 
plot(air.temp ~ time.h, data = wthr, type = 'o')
```

Here we will use these weather data with different types of slurry.

```{r}
dat <- data.frame(ekey = rep(1:3, each = 85), wthr[rep(1:85, 3), ])
head(dat)
tail(dat)
```

Here we need to explicitly add an application event key column, because we have multiple rows (168) for each event.

```{r}
slurry <- data.frame(ekey = 1:3, man.soure = c('cattle', 'pig', 'cattle'),
                     TAN.app.tot = c(1, 2, 3),
                     man.dm = c(6.2, 3.9, 8.0), man.ph = c(7.0, 7.5, 7.9))
dat <- merge(dat, slurry)
head(dat)
```

```{r}
ei <- alfamei(dat, time.name = 'time.h', app.tan.name = 'TAN.app.tot',
              eventkey = 'ekey',
              uncert = c('pars', 'input'), uncert.settings = uset)
```

```{r}
ei$emisdis
ei$emisagg
```

# Aggregation
Any variable (or combination of variables) can be used to aggregate results.

```{r}
dat <- data.frame(app.key = 1:5,
		  zone = c('north', 'north', 'south', 'east', 'west'),
		  sector = c(1, 2, 1, 1, 1),
		  man.source = c('cattle', 'pig', 'cattle', 'cattle', 'pig'),
		  man.dm = c(7, 4, 6.5, 6.5, 4),
		  man.ph = c(7.0, 7.2, 6.9, 7.5, 7.4),
		  app.mthd = c(rep('trailing hose', 4), 'broadcast'),
		  wind.sqrt = sqrt(c(2.2, 2.1, 4.0, 3.7, 4.0)),
		  air.temp = c(12, 8, 8, 15, 14),
		  time.h = 168,
		  TAN.app.tot = c(2000, 1500, 80, 4300, 25))
```

Apply in multiple years.

```{r}
dat <- data.frame(year = rep(2010:2015, each = 5), dat[rep(1:5, 6), ])
```

```{r}
args(alfamei)
```

```{r}
ei <- alfamei(dat, time.name = 'time.h', app.tan.name = 'TAN.app.tot',
              uncert = c('pars', 'input'), uncert.settings = uset)
```

Here our default aggregation, which gives the total for all events, doesn't make much sense because multiple years are combined.

```{r}
ei$emisagg
```

```{r}
args(alfamei)
```

```{r}
alfamei(dat, time.name = 'time.h', app.tan.name = 'TAN.app.tot',
	aggkey = 'year', 
        uncert = c('pars', 'input'), uncert.settings = uset)$emisagg
```

```{r}
alfamei(dat, time.name = 'time.h', app.tan.name = 'TAN.app.tot',
	aggkey = c('zone', 'man.source', 'year'), 
        uncert = c('pars', 'input'), uncert.settings = uset)$emisagg
```


